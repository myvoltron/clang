#include<stdio.h>

int main() {

    int a[1000], b[1000], c[1000]; // a집합이랑 b집합이랑 완전히 다를 때 이걸 수용하려면 c집합이 200이 되어야한다 근데 그냥 다 1000으로 맞추면 해결됨.
    int i = 1, j, cnt = 0, k = 1, cnt2 = 0, cnt3 = 0, save = 0, cnt4 = 0;
    //i = 1로 초기화하고 k 도 1로 초기화한다, j를선언하고 cnt,cnt2,cnt3,cnt4,save를 0으로 초기화한다.
    scanf("%d", &a[0]); //a[0]에 숫자를 입력합니다.
    c[0] = a[0]; //c[0]에 a[0]를 대입합니다.
    while (1) //계속 반복합니다.
    {
        scanf("%d", &a[i]); //  a배열에 숫자를 입력합니다.   2 4 6 7 8 1 2 3 4 -1         1 2 3 4 2 4 6 7 8 -1 
        if (a[i] < 0) break; // a[i]가 음수면 반복문을 탈출합니다.
        for (j = 0; j < i; ++j) //a배열에서 중복된게 있는지 확인하기 위해 반복합니다.
        {
            if (a[j] == a[i]) //a[i]가 중복되었는지 확인하기 위해서 a배열 처음부터 a[i]까지 검사합니다.
            {
                cnt++; // 중복된게 있으면 cnt를 1씩 증가시킵니다.
            }
        }

        if (cnt == 0) //만약 중복된게 없어서 cnt가 0이라면 
        {
            c[k] = a[i]; //c[k]에 a[i]를 대입합니다.
            k++; // k를 1씩 증가시킵니다.
            cnt3++; // cnt3를 1씩 증가시킵니다. cnt3으로 c배열의 실질적인 원소개수를 알 수 있습니다.
        }
        cnt4++; //cnt4를 1씩 증가시킵니다. a배열에 입력받은 원소들의 개수, 실질적인 원소 개수를 알 수 있습니다.
        cnt = 0; //cnt는 재사용해야하니 다시 0으로 초기화시킵니다.
        i++; //i를 1증가시킵니다. 그래서 배열의 다음원소를 검사할 수 있습니다.
    }

    i = 0; //i를 0으로 초기화합니다
    j = 0; //j를 0으로 초기화합니다
    cnt = 0; //cnt를 0으로 초기화합니다


    scanf("%d", &b[0]); //b[0]에 숫자를 입력합니다.
    // b[0] 가 중복되었는지 확인합니다.
    for (i = 0; i <= cnt3; ++i) //아직까지 c배열에 cnt3개의 원소가 있으니 cnt3 까지 반복합니다.
    {
        if (c[i] == b[0]) //c배열의 원소중 b[0]와 겹치는게 있다면
        {
            cnt++; // cnt를 1증가시킵니다.
        }
    }

    if (cnt == 0) //cnt가 0이라면 중복된게 없다는 것입니다.
    {
        c[k] = b[0]; //c[k]에 b[0]를 대입합니다.
        k++; //k를 1증가 시킵니다.
        cnt3++; //cnt3을 1증가시킵니다.
    }

    i = 1; //i를 1로 초기화합니다.
    j = 0; //j를 0로 초기화합니다.
    cnt = 0; //cnt를 0로 초기화합니다.

    while (1)
    {
        scanf("%d", &b[i]); // b[1]부터 계속해서 숫자를 입력받습니다.    1 1 1 1 1 1 1 1 1 1 -1 
        if (b[i] < 0) break; // b[i]가 음수라면 반복문을 탈출합니다.
        for (j = 0; j < i; ++j) //b배열에서 중복된게 있는지 확인하기 위해 반복합니다.
        {
            if (b[j] == b[i]) //b[i]가 중복되었는지 확인하기 위해서 b배열 처음부터 b[i]까지 검사합니다.
            {
                cnt++; // 중복된게 있으면 cnt를 1씩 증가시킵니다.
            }
        }

        for (j = 0; j <= cnt4; ++j) //b[i]가 a배열의 원소들과도 중복되는게 있는지 확인하기 위해서 반복합니다.
        {
            if (a[j] == b[i]) //b[i]가 a배열의 원소들과 겹치는게 있다면
            {
                cnt2++; //cnt2를 1증가시킵니다.
            }
        }

        if (cnt == 0 && cnt2 == 0) //만약 중복되는게 전혀없어서 cnt, cnt2가 0이라면
        {
            c[k] = b[i]; //c[k]에 b[i]를 대입합니다.
            k++; //k를 1증가시킵니다.
            cnt3++; //cnt3을 1증가시킵니다. 따라서 c배열의 총크기를 알 수 있습니다.
        }
        cnt = 0;  //cnt를 계속 사용하기 위해 0으로 초기화합니다.
        cnt2 = 0; //cnt2를 계속 사용하기 위해 0으로 초기화합니다.
        i++; //i를 1증가시킵니다.
    }

    i = 0; //i와j를 재사용하기 위해서 0으로 초기화합니다.
    j = 0;

    //오름차순 정렬하는 부분입니다.
    for (i = 0; i <= cnt3; ++i) // cnt3 까지 반복합니다.
    {
        for (j = 0; j < cnt3; ++j) // cnt3 까지 반복합니다.
        {
            if (c[j] >= c[j + 1]) // 만약 c[j]가 c[j + 1]보다 크다면 
            {
                save = c[j + 1]; //save에 c[j + 1]를 저장하고
                c[j + 1] = c[j]; //c[j + 1]에 c[j]를 대입합니다.
                c[j] = save; //그 후 c[j]에 저장해 놨던 save를 대입합니다.
            }
        }
    }

    //마지막으로 c배열(합집합)을 출력하기 위한 부분입니다.

    for (i = 0; i <= cnt3; ++i) //cnt3을 활용해 c배열에 대입된 원소들을 출력할 수 있습니다.
    {
        printf(" %d ", c[i]); //c배열의 처음부터 출력합니다.
    }

    return 0;
}